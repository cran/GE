% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gemstEndogenousUtilityFunction.R
\name{gemstEndogenousUtilityFunction}
\alias{gemstEndogenousUtilityFunction}
\title{An Endogenous Utility Function}
\usage{
gemstEndogenousUtilityFunction(...)
}
\arguments{
\item{...}{arguments to be passed to the function sdm2.}
}
\description{
This is an example of the market-clearing path with an endogenous utility function.
The parameters of the utility function will change with the utility level.

To deal with non-homothetic preferences, we can simply use an endogenous CES-type utility function instead of a utility function with a more complex form.
}
\examples{
\donttest{
dst.firm <- node_new(
  "output",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer <- node_new(
  "utility",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

ge <- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 1
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(0.01, 1),
  p0 = c(1, 1),
  ts = TRUE,
  policy = list(
    function(A, state) {
      util <- state$last.z[2]
      beta2 <- 0.95 * plogis(util, location = 2, scale = 2)
      A[[2]]$beta <- c(1 - beta2, beta2)
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 20,
  maxIteration = 1
)

matplot(ge$ts.z, type = "b", pch = 20)
ge$z
dst.consumer$beta
}

}
